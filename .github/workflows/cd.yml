# CD Workflow - Build Docker Image and Deploy
# Self-hosted runner on Proxmox for direct deployment

name: CD

on:
  push:
    branches: [main]
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# Explicit permissions for least-privilege principle
permissions:
  contents: read

jobs:
  # ============================================
  # Build and Push Docker Image
  # ============================================
  build:
    name: Build Docker Image
    runs-on: self-hosted
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write
      security-events: write

    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      short-sha: ${{ steps.vars.outputs.short-sha }}
      image-name-lower: ${{ steps.vars.outputs.image-name-lower }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set output variables
        id: vars
        run: |
          echo "short-sha=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT
          echo "image-name-lower=${IMAGE_NAME,,}" >> $GITHUB_OUTPUT

      - name: Normalize image name to lowercase for GHCR
        run: echo "IMAGE_NAME=${IMAGE_NAME,,}" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest
            network=host

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix=,suffix=,format=short
      - name: Build Docker image (load locally for scan)
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          target: runner
          push: false
          load: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.short-sha }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: Run Trivy vulnerability scanner
        id: trivy
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.short-sha }}"
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH"
          exit-code: "1"

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

      - name: Push Docker image
        if: success()
        run: |
          PRIMARY_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.short-sha }}"
          echo "Using primary tag: $PRIMARY_TAG"
          echo "${{ steps.meta.outputs.tags }}" | while read -r TAG; do
            if [ -n "$TAG" ]; then
              docker tag "$PRIMARY_TAG" "$TAG"
              docker push "$TAG"
            fi
          done

      # Prevent cache from growing indefinitely
      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  # ============================================
  # Deploy to Production
  # ============================================
  deploy:
    name: Deploy to Production
    runs-on: self-hosted
    timeout-minutes: 15
    needs: [build]
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: read
      packages: read
    environment:
      name: production
      url: ${{ vars.PRODUCTION_URL }}

    env:
      DEPLOY_PATH: ${{ vars.DEPLOY_PATH || '/opt/next-payload-starter' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create deployment directory
        run: mkdir -p "$DEPLOY_PATH"

      - name: Backup current configuration
        run: |
          cd "$DEPLOY_PATH"
          if [ -f docker-compose.yml ]; then
            cp docker-compose.yml docker-compose.yml.bak
            echo "Backed up docker-compose.yml"
          fi
          if [ -f .env ]; then
            cp .env .env.bak
            echo "Backed up .env"
          fi

      - name: Copy deployment compose file
        run: cp compose.deploy.yaml "$DEPLOY_PATH"/docker-compose.yml

      - name: Create .env file for deployment
        run: |
          cat > "$DEPLOY_PATH"/.env << 'EOF'
          # Application
          DATABASE_URI=${{ secrets.DATABASE_URI }}
          PAYLOAD_SECRET=${{ secrets.PAYLOAD_SECRET }}

          # PostgreSQL
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}

          # Cloudflare Tunnel
          CLOUDFLARE_TUNNEL_TOKEN=${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}

          # Docker Image
          PAYLOAD_IMAGE=${{ env.REGISTRY }}/${{ needs.build.outputs.image-name-lower }}:${{ needs.build.outputs.short-sha }}
          EOF

      - name: Pull latest images
        run: |
          cd "$DEPLOY_PATH"
          docker compose pull

      - name: Deploy application
        run: |
          cd "$DEPLOY_PATH"
          # Stop old containers and start new ones
          docker compose down --remove-orphans
          docker compose up -d

      - name: Wait for application to be ready
        run: |
          cd "$DEPLOY_PATH"
          echo "Waiting for application to start..."
          sleep 10

      - name: Health check
        run: |
          MAX_RETRIES=30
          RETRY_COUNT=0

          # Use curl to check health endpoint from host
          until curl -sf http://localhost:3000/api/health > /dev/null 2>&1 || [ $RETRY_COUNT -eq $MAX_RETRIES ]; do
            echo "Waiting for application to be healthy... ($RETRY_COUNT/$MAX_RETRIES)"
            sleep 5
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done

          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "Health check failed after $MAX_RETRIES attempts"
            exit 1
          fi

          echo "✅ Application is healthy!"

      - name: Cleanup old images
        if: success()
        run: |
          docker image prune -af --filter "until=168h"

      - name: Notify deployment success
        if: success()
        run: |
          echo "✅ Deployment successful!"
          echo "Image: ${{ env.REGISTRY }}/${{ needs.build.outputs.image-name-lower }}:${{ needs.build.outputs.short-sha }}"
          echo "Environment: production"

      - name: Rollback on failure
        if: failure()
        run: |
          cd "$DEPLOY_PATH"
          echo "⚠️ Deployment failed, attempting rollback..."

          # Restore from backup if available
          if [ -f docker-compose.yml.bak ]; then
            mv docker-compose.yml.bak docker-compose.yml
            echo "Restored docker-compose.yml from backup"
          fi
          if [ -f .env.bak ]; then
            mv .env.bak .env
            echo "Restored .env from backup"
          fi

          # Restart with previous configuration
          docker compose down --remove-orphans
          docker compose up -d

          echo "Rollback attempted. Please verify manually."
